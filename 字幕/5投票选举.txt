接下来我们实现选举逻辑
对于选举逻辑来说
我们分RPC的发送方和接收方
对于RPC的发送方来说
我们可以分成三个层次来实现
最外层是一个选举的loop
他会是一个无限的循环
然后不断的检测当前嗯P2是否超市
以及是否适合发起选举
如果发现满足呃发起选举的条件
那就开始进行选举
每次选举的话啊
我们第二个层次就是进行一轮要票
针对除自己之外的其他的所有片儿呃
对端进行一次要票
然后第三个层次就是一次真正的RPC
就处理对每一个对端
每一个P2呃
他的RPC发送和回复处理的逻辑
那最后还有一块
就是RPC的接收方的投票逻辑
就是说你作为一个被要票的人
你收到一个投票请求
你是否要投给他
那这在我们的代码中表现为一个回调函数呃
最终是由RPC框架来决定
这个回调函数什么时候调用的
OK主要就分这四个部分
接下来我们详细看一下代码
那在实现我们这个选举的loop的时候
我们最重要的就是要呃需要两个函数
第一个函数就是我们需要重置这个选举的呃
timer适中
但我们在实现的时候不会真用go浪里面的timer
我们会用loop加sleep的方式
所以呃关键是我们要注嗯
我们要实现这个sleep interval的
因为他在论文中要求是一个随机数
所以我们要它是在一定范围内随机
所以我们首先要实现这个的获取嗯
其次呢我们还需要一个函数
就是要判断当前是否已经超时
那我们主要就需要这两个函数
具体我们可以这么来实现
首先我们用常量来
定义一下我们的选举
超时的上下界
至于上下届的选取为什么是二百五和400
这个我们在文档里有讲
大家可以去看一下
它无论上界和下界都是不能过小或者过大的
呃我们把它配置成常数
并放在开头的原因
就是我们如果发现他们不合适了
可以方便直接修改这儿进行调试
当然我们还可以诶做成一个下界
加一个呃interval的方式
比如说250+150的间隔
但是这样会更符合论文
更直观一些
但就是我们在计算的时候
也就是构造我们之后的两个函数的时候
会进行一步额多一次的上下界相减的运算
也就是
第一个函数就是我们需要重置
时不时的就在我们收到leader的呃
同步日志或者投给其他candidate的票之后
我们要重置我们的选举时钟
就是这个函数
由于它要修改一些全局变量
所以也要加速之后才能用
首先我们要把计时起点设到当前
然后我们会算一个随机的超市时间
这样我们就做了两件事
第一件事就是确定这一轮四的即时起点
确定这一轮次的超时间隔
它是在min和max之间的一个随机数
然后第二个函数就是要判断当前有没有超时
这个因为要访问全局变量
所以也要加锁
所以我们加一个lock的后缀
嗯这个很简单
就是判断当前时间和计时起点
和本轮次的计时起点的差值
是否比嗯这一轮次的考试间隔要大
这是要返回一个布尔值的
那再有了这两个检测是否超时的函数之后呢
我们就可以构造我们的loop了
我们的loop是一个和raft instance
时间周期相同的一个loop
也就是说
只要我们的make a函数构造好P2的时候
它就会一直在后台运行
也就是这个tick
由于之后我们还要一个还有其他两个loop
所以嗯当然loop在这称为TIK
为了额
因为他们都叫ticker
为了进行区分
我们给它加一个前缀
这个就叫做election ticker
把该修改一下
嗯这就是最外层是一个检测是否DECO的循环
我们可以直接通过这种来检测
把它修改的简单一些
然后加上这个每一个
因为我们要每次外最外层一个循环
只要没有死
就会一直再循环
然后每次嗯循环嗯
在睡眠一段时间之后换题
然后就看当前有没有选举超时
然后发起选举
因为我们在发取检测是否超时的时候需要上锁
所以在外层先加一个锁
这样我们就在锁之间框出一段连接区
它是线程安全的
然后就可以方便的检测是否超时
以及如当前是否是主
如果当前已经是leader的话
如果已经是例D的话
那肯定就不用发去选举
因为我们选举的唯一目的就是当选例的
如果你本来你已经在leader任上
然后你还去选举
就相当于你自己会把自己冲掉
肯定是不会这样干的
然后第二个就是嗯检测当前是否超市
如果不是leader
并且已经额选举超时
选举时钟超时了
则立即变candidate
然后把自己term加一投票给自己
这个逻辑都在这里面
然后呢就开始进行发起选举
好这个loop就这么简单就完了
需要注意的是
底下我们在sleep的时候
也是随机进行sleep的
就sleep一个随机的时间
而不是sleep一个固定的时间
这是因为如果我们sleep固定时间的话
哪怕我们的超时间隔是随机的
但由于我们的检测点是固定间隔的
所以有可能导致啊两个不同的片
而它在检测的时候就是会同时检测到超市
即使他们的呃超时间隔并不一致
但是因为我们检测间隔一致
也会造成超时
OK接下来我们勾到第二层偏内层的一次
呃要票的逻辑
这就是我们会对除自己之外的片
每个片都去发一个RPC
这有一个term的参数的原因是
因为我们在发起选举
只对这一个term负责和有效
如果我们嗯在中途嗯
处理发送RPC或者处理RPC的时候
发现我们的term已经change了
那么这个函数其实就不用接着再往下走了
直接返回就可以了
所以我们需要这么一个term的参数
首先我们定义一个票数的局部变量来进行计票
接着我们就要对
每一个片
构造参数
然后发送RPC
并且处理返回值
由于这我们要访问我们的rap的全局变量
所以我们要加速
如果是自己呢就跳过
但是要给自己的投票制加上
然后如果不是自己
则去构造一下RPP的要票的参数
哦这儿勾long
我们不能在前面加的
我们这儿需要定义一下
我们在这一部分实现
由于所有日志相关的参数都不用管
也就是说我们现在并不需要比较日志谁先谁后
我们可以在下一个part part b的时候
来实现这些逻辑
那本人的逻辑就很简单了
我们只需要一个tom表明自己
candidate term是多少
因为所有比较都是基于term一致展开的
如果term不一致
就要进行
你要么变follower
要么拒绝你的请求
其次呢你要告诉哦
candy的id
我是谁
那一到我们把request word reply写上
首先也是需要一个term
把被要票者的呃term带回来
以就相当于如果自己发现了更高的term
则使用该term来把自己的term带上去
并且变成follow
然后呢
他还得需要一个额是否投给你的物体的grand
这几个参数在论文里都有
大家可以直接抄过来
需要注意的就是首字母都要大写
否则的话
我们的RPC框架
没有办法对它这些参数进行序列化和反序列化
也就无法在RPC的两端之间进行传播
term呢就取我们当前的term
然后candy的id呢就是我们自己的标号
然后就可以去要票了
由于这个是在临界区内
所以我们要异步的进行摇票
而不能同步的发送RPC
否则可能会造成死锁
就是所有需要长时间IO的这种过程
都不能在连接区里面
都要及时把锁释放掉
然后我们再来构造这个函数
我们这个使用一个局部的嵌套函数
是
因为这样我们就可以方便的对这个变量进行嗯
在处理返回值的时候进行加价
这也就是我们的第三个层次
就是最底层的对一个P2发起RPC
并且处理返回值
看人家是否投给自己的票的这么一个逻辑
首先我们要构造一下
构造一个空的返回值结构体
因为我们的RPC需要的是一个指针
所以需要先把这个结构结构导出来
然后我们来发送RPC
这个函数因为是RPC函数
所以你不知道它什么时候返回
所以不能在临界区之内
也就是说不能给他上锁啊
当然也无需上锁
因为他是线程安全的
接下来我们嗯处理我们的response
在这就需要上锁了
因为我们会访问并操作rap的一些全局字段
首先我们判断RPC请求是否成功
如果不成功的话
我们就及时返回
并且打一条日志
并且带出一定的信息
我们到底是问谁要票失败了
接下来嗯第一步就是在我们的所有嗯
无论是收到一个RPC还是RPC请求
还是处理RPC结果的时候
就是收到一个RPC的返回的时候
我们第一步要做的就是要对其
Term
因为只有在同term下
我们之后的状态机才能够推进
否则的话我们的逻辑都会出现问题
如果发现人家的term比我们大的话
我们现在应该是candidate
那其实直接哎就不用做CANDATE
直接变成follower就可以
然后终止要票过程返回
嗯如果他比我们小呢
就不用管
因为他比我们小
他会变成follower
并且投给我们票
接下来第二步就是嗯
看我们的我们自己的term是否发生了变化
也就是嗯我们用一个叫做contest是否lost
因为他也得在临界区里面使用
我们定义一下这个函数
这个函数的意思就是检测我们自身嗯
是否仍为我们发送RPC之前
认为我们自己的角色
以及我们当前是否仍然处于
我们是自自认为的term
因为我们在RPC收到IPC
或者说到RPC返回值的时候
你其实不知道过了多少时间
你也不知道你的上下文是否
因为其他线程的并发操作
已经就是说你已经不是candidate了
你已经不是follower了
或者你已经不在你认为的term上了
那在这时候都要及时终止我们这些回调函数
或者请求返回的处理
否则的话就会让状态机出现问题
因为你在一个不正确的假设上进行
进行了状态机的推进就会产生问题
所以我们要检测水
可检测我们的
这两个东西term和roll
返回一个布尔
在这我们得认为我们还在执行这个过程
我们必须是candidate
并且我们的term是传进来的term
因为这个函数只负责这一个term的选举
如果当前我们term已经发生了变化
那就不是这个函数该管的事情了
我们会有一个新的函数来管这些事情
嗯到这我们就直接返回
然后打一条日志
最后在对齐term
并且上下文没有丢失
也就是说我们仍是那个角色
和在那个term的时候
我们再来检查我们的当前的人家
是否投给了我们票
添点注释
然后我们每测
如果发现WSS大于半数之后
嗯这我们是大于而不是大于等于的
原因在于我们是向下取整
所以是需要大于
我们就会变成leader
然后发起
心跳和日志同步
我们不妨称之为replication ticker
和我们下面这个election ticker相对
他也需要创建一个term进去
也就意味着它只有在这个term的时候才会主
如果之后的一切状态随变了
不在这TM他都要及时终止这个函数
好这儿
其实我们这个发送方的逻辑就完了
但其实我们在构造函数进行
我们在对我们在进来这个选举函数的时候
因为我们也是用了一个go routine
所以最好就所有这种异步的都先检查一下
我们的context是否lost
因为如果已经饿死了的话
其实后面这些就都完全不用管
不用干了
而不用到哦
我们在处理RPC返回的时候才去检测
这样可以提前嗯规避一些事情
就如果我们这个函数一进来就发现
我们已经不是在这个term的candidate了
那直接其实就可以返回就好了
嗯在这我们也加一条日志吧
日志不要过长
但要体现关键信息
但我们怎么知道哪些是关键信息呢
嗯这个完全是基于经验
一开始的话我们可以嗯随便写
等之后我们在调试的时候
我们会发现嗯有一些信息我们想看
但是没有
然后再回来加
所以这呃一开始不知道写哪些关键信息
也没有事情
这都是一个经验的问题
在你调试的过程中就会发现哪些需要写
哪些是冗余的
好那个发送方的逻辑就这样了
然后我们接下来实现这个回调函数
也就是接收方的逻辑
我们在嗯接收方的时候
嗯接触到RPC的第一件事情
也是要
对齐
Term
那当然这些处理额我们都先加一把大锁
加锁的原则就是一开始都先加一把大锁
然后发现有问题再拆分嗯
有性能问题再进行拆分
当然如果有思索也得需要呃注意
但需要额虽然是一把大锁
也要注意
不要把一些长时间的L
比如说RPC的过程给加进去
好在此之前
我们先把返回值构造一下
百分之现在主要有term和是否投给了彩票
Vogranted
后者的话需要根据每一个逻辑来判断
首先我们要对齐term
我们如果发现人家的term比我们小
那集直接拒绝这个请求就行了
因为term在rap的本质是一种嗯EPOC
或者说一种优先级的概念
就所有具有高term的皮尔
可以无视第一term的任何请求
并且告诉他我比你高
你赶紧给我
你赶紧跟上我
那么其他的PR通过IPC知道了之后
就要及时跟上
并且变follower
所以对这种请求我们直接拒绝就好
然后打上一条日志
还是说这个日志的信息
大家可能会好奇
为什么那么打
我也是我也是先打这些
根据我之前的经验等
之后如果出现问题
调试的时候有问题
咱们再回来完善或者去掉一些荣誉的信息
然后如果人家的term比我们大
我们就要变follower
但是变了follower要反了么
不变了
follower你反而还要投票
因为变了follower之后
你的投票肯定就空出来了
也就是说我们在变follower的时候
你如果别人比我们大
我们是会把投票滞空的
这时候你就在本轮次就可以进行投票
所以我们这不能返回
要接着进行以下的逻辑
到这我们就把请求方的term和我们的term呃
进行了对齐
就会比我们小
比我们大的逻辑进行进行处理
那到了这的话嗯
请求方的term和我们的term就一致了
然后我们就需要check the word for
也就是看我们是否在本轮次投过票
如果我们投过
那就拒绝
这次要不要请求
这我们有一个空格的原因是因为我们在这
其实我们在log里隐含的加了一个空格
所以我们在后面为了让箭头两侧是对称的
所以这也加一个空格
你拒绝了CANDATE的投票
因为我们已经投给了某个人
能返回
接下来其实如果我们在正常的rap的逻辑里
还要比较我们的日志是否哦比你的心
如果我们比你的心
我们就不投给你
如果你的更新
我们就投给你
但是因为由于怕太黑
我们不涉及日志这一块的逻辑
所以我们就直接可以把票投给你了
首先通过reply告诉我
我可以给你票
哦当然这儿我们在返回的时候
忘了说它是false
但是我们可以在外外面给它
默认的给它复制成false
就表示我们默认是不给你票的
只有到了层层过滤
最后之后我们发现所有条件都满足了
我们才会给你标
然后第一句是告诉你
我给你票
第二句是我自己要记下的
我已经给了这个人票
并且如果我在给出票去之后
就相当于我认可了你这个candidate
你可以有变成leader的潜质
那也就类似于
其实我收到了准leader或者leader的这种请求
我就可以重置我自己的选举失重
来给你提供一个保证
我暂时不会发起新的选举
然后打一条日志
嗯这个大消息我也搞得不太一致
大家可以自己搞一下
比如所有逗号之后都可以大一些
但也可以指首字母大写
这个都无关紧要
但是已知的话会好看一些
到这儿我们就实现了part a中
所有关于选举的逻辑
之后
下一个视频我们会讲
实现那个不带日志的心跳逻辑
