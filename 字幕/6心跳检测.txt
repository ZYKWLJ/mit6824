本次我们来实现心跳的逻辑
这次心跳的逻辑注意是不包含任何日志的
到part b的时候
我们再包含日志进去
所以这次的心跳逻辑会比较简单
和选举逻辑相对
我们也用三个层次来实现心跳发送方
也就是leader的这边的逻辑
那么我们最外层就是从一个ticker出发
这个ticker我们称之为replication ticker
他同时兼有两种功能
一个是心跳
那在没有日志可发作用的时候
就是心跳
有日志可发动的时候
就充当日志同步的RPC
那接下来我们从这儿开始实现
这个就是说在这个term内
它可以作为leader一直发送日志
如果发现那当前的term变了
或者自己不是leader了
那就要及时从这个循环中退出来
他和选举逻辑一直在后台运行
不同他的时间它的生命周期是一个term
就是这个TIKER的生命周期是一个term
而不是整个呃P2的生命周期
这个要和选举逻辑进行区分
所以他和选举逻辑不同的一点
就是它有这个term的参数
就他只能加一些呃
注释
只有在这个term内才能进行日志同步
如果发现term变了
就及时进行退出
那我们的最外层的loop也用一个和
Election loop
相同的这种结构
不同的是我们只需要
sleep有个固定的时间间隔就可以
我们不妨称之为replicate inter
然后在这个在这儿进行常量定义
我们这个interval呢要比额选举的下届还要小
才能抑制呃
任何一个有异心的P2发去选举
就只要网络通畅
所以这要比他小
我们不妨设为200
然后有了这个固定的额日志同步
或者说心跳间隔之后
我们就来完善一下这个逻辑
接下来就是第二个层次
我们每次时间点一到
就对除自己之外的所有pr发送一轮RPC
我们称这个函数叫啊
和那个选举函数叫start election
我们这个就叫做start replication
这儿有一个返回值
这个是和选举函数不同的
这个返回值的含义是我们是否成功的啊
发起了一轮心跳
那这个成功的标志是什么呢
也就是我们上下文有没有变化
如果变化了
也就意味着我们不是本term的leader了
那就要及时退出循环
然后接下来我们实现嗯
第二个层次发送一轮的RPC
它的基本逻辑也很简单
就是对所有的pr
遍历所有的PRID
然后呢如果发现是自己就跳过
如果
不是自己是其他的片
就要构造这个RPC的参数
这儿要RPC的参数
我们还没有定义
然后来定义一下
主要包括两个append entr
这个在rap论文里的图二照着抄就可以
就这个rap的paper
照着这个抄就可以
但所有和log相关的
我们这一题都可以先不管
所以只要这两个就可以
然后是RPC的返回参数
也是需要有一个term
有一个success
注意首字母都需要大写
所以这里我们接着对每一个pr
除自己之外来构造RPC的请求参数
我们都用指针
term是自己锻炼
term leader id是自己的id
这里
需要注意的是
因为访问了这些carry on term
这有可能会在并发的进行修改
所以外面就要加速
以确保我在嗯进行这个逻辑的时候
构造逐一对每一个pr构造参数发送RPC的时候
我这些嗯全局的数据结构不会发生变化
嗯当然在这个里面应
因为我们说提到他和选举逻辑还不一样
它需要一个返回值
这个就涉及到我们一进来就需要检测
我们的context是否还在
也就是说我们是否仍然是这一个term的leader
如果不是了呢
那就直接返回false打一条日志吧
记录一下它是从嗯哪个term开始丢的
然后回到这儿来
那我们就对每一个pr来发送
我们构造的RBC参数
这个我们也定义在局部吧和
请求和选举逻辑保持一致
这个的基本逻辑也是一样
先利用我们传入的参数来发送RPC
那我们发送2BC的时候
它的形式也和呃选举逻辑那一块一样
先构造一个reply的空结构体
因为我们的RPC需要一个指针
所以要先把这个结构结构造出来
然后去发送RPC
Send a pen
嗯这个发送RBC的函数我们还没有
我们因为嗯这边给了发送
选举的请求的RBC我们可以直接抄过来
在抄过来之后
记得一定要把这个路由的参数改了
这样才能正确的找到对端pr的相应的回调函数
这回答还是我们还没有实现
一会去实现
嗯这是一个指针
接下来我们就需要处理回调
不是需要处理RPC的返回值
首先看请求是不是正确的啊
发出来或者收到和收到
这个是RPC框架实现的
它通过一个布尔变量来告诉我们
RPC是否发送成功
如果没有成功
能打条日志
然后返回就行
接下来呢要对齐
如果对方的term
也就是说你本来以为对方只是follower
结果没发现嗯
对方的follower term还比你高啊
对他也可能是嗯candidate或者leader
但发现无论如何
发现他term比你高之后
你自己就要及时的变成
之后由于我们不需要进行日志的处理
所以之后就没有了
如果我们需要后面处理日志的话
还是要在处理日志之前
要先检查自己的context是否lost和之前一样
嗯接下来我们实现一下
接收方的这个心跳的
OPPENTRIES回调函数
这个回调函数要注意它的首字母是大写的
和其他的不一样
这是因为这儿和这儿的名字要一一对应
否则的话
这个发送方就找不到接收方的这个回调函数
它是根据名字来找的
我们接收方在接收到当前
也就是嗯他是毕业
不管别人是不是认为他是leader
反正他自认为是某个term的leader的情形的时候
我们要进行以下的逻辑
首先要加速
然后加速制造一个连接区
然后我们在无论是收到RPC
还是收到RPC的返回值的时候
第一个的就是要对齐term
如果我们发现对leader的term比我们小
那直接无情的拒绝
带一条日志
嗯需要把拒绝了谁term
这些关键信息可以打出来
我们是拒绝了这个leader
然后
你的term是他自认为的term是这个
我们的term是这个
然后返回
那如果对方的term比我们大
或者和我们相同
那我们就认可对方这个leader
这里需要注意同一个term的话
是不可能出现两个力量的
也就是说如果我们相同term
不可能对方是leader
我们自己也是leader
因为选举的话是需要一个多数票的
根据各种原理
不可能在同一个term中出现两个多数票的集合
因为他们一定是有交集的
所以我们在这种情况下就直接变嗯
flower就可以
然后最重要的一点就是
不要忘记重置自己的时钟
好
这个现代逻辑到这儿就实现完了
