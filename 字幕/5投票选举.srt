0
00:00:00,062 --> 00:00:02,071
接下来我们实现选举逻辑

1
00:00:02,071 --> 00:00:04,033
对于选举逻辑来说

2
00:00:04,033 --> 00:00:07,039
我们分RPC的发送方和接收方

3
00:00:07,039 --> 00:00:09,809
对于RPC的发送方来说

4
00:00:09,809 --> 00:00:12,289
我们可以分成三个层次来实现

5
00:00:12,289 --> 00:00:15,429
最外层是一个选举的loop

6
00:00:15,429 --> 00:00:18,091
他会是一个无限的循环

7
00:00:18,091 --> 00:00:24,007
然后不断的检测当前嗯P2是否超市

8
00:00:24,007 --> 00:00:27,032
以及是否适合发起选举

9
00:00:27,032 --> 00:00:31,076
如果发现满足呃发起选举的条件

10
00:00:31,076 --> 00:00:33,044
那就开始进行选举

11
00:00:33,044 --> 00:00:35,062
每次选举的话啊

12
00:00:35,062 --> 00:00:39,001
我们第二个层次就是进行一轮要票

13
00:00:39,001 --> 00:00:44,019
针对除自己之外的其他的所有片儿呃

14
00:00:44,019 --> 00:00:46,017
对端进行一次要票

15
00:00:46,017 --> 00:00:49,007
然后第三个层次就是一次真正的RPC

16
00:00:49,007 --> 00:00:51,079
就处理对每一个对端

17
00:00:51,079 --> 00:00:53,097
每一个P2呃

18
00:00:53,097 --> 00:01:00,024
他的RPC发送和回复处理的逻辑

19
00:01:00,024 --> 00:01:01,008
那最后还有一块

20
00:01:01,008 --> 00:01:05,000
就是RPC的接收方的投票逻辑

21
00:01:05,000 --> 00:01:08,064
就是说你作为一个被要票的人

22
00:01:08,064 --> 00:01:10,044
你收到一个投票请求

23
00:01:10,044 --> 00:01:12,062
你是否要投给他

24
00:01:12,062 --> 00:01:18,083
那这在我们的代码中表现为一个回调函数呃

25
00:01:18,083 --> 00:01:21,035
最终是由RPC框架来决定

26
00:01:21,035 --> 00:01:23,077
这个回调函数什么时候调用的

27
00:01:23,077 --> 00:01:26,041
OK主要就分这四个部分

28
00:01:26,041 --> 00:01:29,025
接下来我们详细看一下代码

29
00:01:30,066 --> 00:01:34,009
那在实现我们这个选举的loop的时候

30
00:01:34,009 --> 00:01:39,069
我们最重要的就是要呃需要两个函数

31
00:01:39,069 --> 00:01:47,098
第一个函数就是我们需要重置这个选举的呃

32
00:01:47,098 --> 00:01:49,004
timer适中

33
00:01:49,004 --> 00:01:52,098
但我们在实现的时候不会真用go浪里面的timer

34
00:01:52,098 --> 00:01:57,038
我们会用loop加sleep的方式

35
00:01:57,038 --> 00:02:00,062
所以呃关键是我们要注嗯

36
00:02:00,062 --> 00:02:05,499
我们要实现这个sleep interval的

37
00:02:05,499 --> 00:02:08,539
因为他在论文中要求是一个随机数

38
00:02:08,539 --> 00:02:12,041
所以我们要它是在一定范围内随机

39
00:02:12,041 --> 00:02:15,082
所以我们首先要实现这个的获取嗯

40
00:02:15,082 --> 00:02:17,005
其次呢我们还需要一个函数

41
00:02:17,005 --> 00:02:21,008
就是要判断当前是否已经超时

42
00:02:21,008 --> 00:02:25,062
那我们主要就需要这两个函数

43
00:02:25,062 --> 00:02:28,004
具体我们可以这么来实现

44
00:02:29,042 --> 00:02:33,003
首先我们用常量来

45
00:02:35,056 --> 00:02:39,084
定义一下我们的选举

46
00:02:39,084 --> 00:02:41,008
超时的上下界

47
00:03:06,007 --> 00:03:10,018
至于上下届的选取为什么是二百五和400

48
00:03:10,018 --> 00:03:12,002
这个我们在文档里有讲

49
00:03:12,002 --> 00:03:13,068
大家可以去看一下

50
00:03:13,068 --> 00:03:19,005
它无论上界和下界都是不能过小或者过大的

51
00:03:20,056 --> 00:03:22,004
呃我们把它配置成常数

52
00:03:22,004 --> 00:03:24,032
并放在开头的原因

53
00:03:24,032 --> 00:03:27,017
就是我们如果发现他们不合适了

54
00:03:27,017 --> 00:03:30,048
可以方便直接修改这儿进行调试

55
00:03:30,092 --> 00:03:35,000
当然我们还可以诶做成一个下界

56
00:03:35,000 --> 00:03:37,073
加一个呃interval的方式

57
00:03:37,073 --> 00:03:40,079
比如说250+150的间隔

58
00:03:40,079 --> 00:03:44,018
但是这样会更符合论文

59
00:03:44,018 --> 00:03:45,002
更直观一些

60
00:03:45,002 --> 00:03:47,044
但就是我们在计算的时候

61
00:03:47,044 --> 00:03:49,066
也就是构造我们之后的两个函数的时候

62
00:03:49,066 --> 00:03:54,093
会进行一步额多一次的上下界相减的运算

63
00:03:54,093 --> 00:03:57,018
也就是

64
00:04:00,098 --> 00:04:05,028
第一个函数就是我们需要重置

65
00:04:05,028 --> 00:04:09,082
时不时的就在我们收到leader的呃

66
00:04:09,082 --> 00:04:12,098
同步日志或者投给其他candidate的票之后

67
00:04:12,098 --> 00:04:15,006
我们要重置我们的选举时钟

68
00:04:15,006 --> 00:04:17,009
就是这个函数

69
00:04:21,076 --> 00:04:24,072
由于它要修改一些全局变量

70
00:04:24,072 --> 00:04:27,092
所以也要加速之后才能用

71
00:04:29,098 --> 00:04:35,006
首先我们要把计时起点设到当前

72
00:04:37,014 --> 00:04:41,082
然后我们会算一个随机的超市时间

73
00:05:23,068 --> 00:05:24,096
这样我们就做了两件事

74
00:05:24,096 --> 00:05:27,092
第一件事就是确定这一轮四的即时起点

75
00:05:27,092 --> 00:05:32,004
确定这一轮次的超时间隔

76
00:05:34,018 --> 00:05:36,086
它是在min和max之间的一个随机数

77
00:05:37,098 --> 00:05:42,046
然后第二个函数就是要判断当前有没有超时

78
00:05:50,074 --> 00:05:53,026
这个因为要访问全局变量

79
00:05:53,026 --> 00:05:54,026
所以也要加锁

80
00:05:55,038 --> 00:05:58,022
所以我们加一个lock的后缀

81
00:06:04,038 --> 00:06:05,054
嗯这个很简单

82
00:06:05,054 --> 00:06:08,068
就是判断当前时间和计时起点

83
00:06:08,068 --> 00:06:11,018
和本轮次的计时起点的差值

84
00:06:11,018 --> 00:06:16,779
是否比嗯这一轮次的考试间隔要大

85
00:06:27,038 --> 00:06:31,058
这是要返回一个布尔值的

86
00:06:32,024 --> 00:06:39,001
那再有了这两个检测是否超时的函数之后呢

87
00:06:39,001 --> 00:06:41,074
我们就可以构造我们的loop了

88
00:06:41,074 --> 00:06:45,018
我们的loop是一个和raft instance

89
00:06:46,018 --> 00:06:48,004
时间周期相同的一个loop

90
00:06:48,004 --> 00:06:49,043
也就是说

91
00:06:49,043 --> 00:06:52,083
只要我们的make a函数构造好P2的时候

92
00:06:52,083 --> 00:06:54,071
它就会一直在后台运行

93
00:06:54,071 --> 00:06:56,169
也就是这个tick

94
00:06:56,169 --> 00:07:00,589
由于之后我们还要一个还有其他两个loop

95
00:07:00,589 --> 00:07:05,048
所以嗯当然loop在这称为TIK

96
00:07:05,092 --> 00:07:07,007
为了额

97
00:07:07,007 --> 00:07:09,004
因为他们都叫ticker

98
00:07:09,004 --> 00:07:10,012
为了进行区分

99
00:07:10,012 --> 00:07:11,004
我们给它加一个前缀

100
00:07:11,004 --> 00:07:14,082
这个就叫做election ticker

101
00:07:18,042 --> 00:07:20,007
把该修改一下

102
00:07:26,042 --> 00:07:31,009
嗯这就是最外层是一个检测是否DECO的循环

103
00:07:31,009 --> 00:07:34,087
我们可以直接通过这种来检测

104
00:07:36,002 --> 00:07:37,007
把它修改的简单一些

105
00:07:37,007 --> 00:07:42,085
然后加上这个每一个

106
00:07:42,085 --> 00:07:46,077
因为我们要每次外最外层一个循环

107
00:07:46,077 --> 00:07:47,091
只要没有死

108
00:07:47,091 --> 00:07:51,023
就会一直再循环

109
00:07:51,023 --> 00:07:55,929
然后每次嗯循环嗯

110
00:07:55,929 --> 00:07:58,769
在睡眠一段时间之后换题

111
00:07:58,769 --> 00:08:02,089
然后就看当前有没有选举超时

112
00:08:02,089 --> 00:08:04,929
然后发起选举

113
00:08:09,012 --> 00:08:15,038
因为我们在发取检测是否超时的时候需要上锁

114
00:08:15,038 --> 00:08:18,039
所以在外层先加一个锁

115
00:08:22,094 --> 00:08:27,042
这样我们就在锁之间框出一段连接区

116
00:08:27,042 --> 00:08:28,074
它是线程安全的

117
00:08:28,074 --> 00:08:32,049
然后就可以方便的检测是否超时

118
00:08:32,049 --> 00:08:36,016
以及如当前是否是主

119
00:08:36,016 --> 00:08:39,046
如果当前已经是leader的话

120
00:08:40,058 --> 00:08:42,056
如果已经是例D的话

121
00:08:42,056 --> 00:08:44,058
那肯定就不用发去选举

122
00:08:44,058 --> 00:08:48,086
因为我们选举的唯一目的就是当选例的

123
00:08:52,008 --> 00:08:55,012
如果你本来你已经在leader任上

124
00:08:55,012 --> 00:08:57,032
然后你还去选举

125
00:08:57,032 --> 00:08:59,006
就相当于你自己会把自己冲掉

126
00:08:59,006 --> 00:09:01,071
肯定是不会这样干的

127
00:09:02,067 --> 00:09:08,007
然后第二个就是嗯检测当前是否超市

128
00:09:10,068 --> 00:09:12,024
如果不是leader

129
00:09:12,024 --> 00:09:15,062
并且已经额选举超时

130
00:09:15,062 --> 00:09:17,005
选举时钟超时了

131
00:09:17,005 --> 00:09:19,086
则立即变candidate

132
00:09:19,086 --> 00:09:23,043
然后把自己term加一投票给自己

133
00:09:23,079 --> 00:09:25,071
这个逻辑都在这里面

134
00:09:26,075 --> 00:09:32,007
然后呢就开始进行发起选举

135
00:09:43,004 --> 00:09:46,063
好这个loop就这么简单就完了

136
00:09:46,063 --> 00:09:47,085
需要注意的是

137
00:09:47,085 --> 00:09:49,047
底下我们在sleep的时候

138
00:09:49,047 --> 00:09:51,023
也是随机进行sleep的

139
00:09:51,023 --> 00:09:53,002
就sleep一个随机的时间

140
00:09:53,002 --> 00:09:55,074
而不是sleep一个固定的时间

141
00:09:55,074 --> 00:09:58,032
这是因为如果我们sleep固定时间的话

142
00:09:58,032 --> 00:10:01,043
哪怕我们的超时间隔是随机的

143
00:10:01,043 --> 00:10:03,091
但由于我们的检测点是固定间隔的

144
00:10:03,091 --> 00:10:08,001
所以有可能导致啊两个不同的片

145
00:10:08,001 --> 00:10:12,086
而它在检测的时候就是会同时检测到超市

146
00:10:14,074 --> 00:10:20,001
即使他们的呃超时间隔并不一致

147
00:10:20,001 --> 00:10:21,071
但是因为我们检测间隔一致

148
00:10:21,071 --> 00:10:23,057
也会造成超时

149
00:10:25,019 --> 00:10:29,087
OK接下来我们勾到第二层偏内层的一次

150
00:10:31,011 --> 00:10:32,059
呃要票的逻辑

151
00:10:33,099 --> 00:10:37,003
这就是我们会对除自己之外的片

152
00:10:37,003 --> 00:10:40,015
每个片都去发一个RPC

153
00:10:52,074 --> 00:10:58,098
这有一个term的参数的原因是

154
00:10:58,098 --> 00:11:02,149
因为我们在发起选举

155
00:11:02,149 --> 00:11:04,949
只对这一个term负责和有效

156
00:11:04,949 --> 00:11:09,005
如果我们嗯在中途嗯

157
00:11:09,005 --> 00:11:12,024
处理发送RPC或者处理RPC的时候

158
00:11:12,024 --> 00:11:14,018
发现我们的term已经change了

159
00:11:14,018 --> 00:11:17,078
那么这个函数其实就不用接着再往下走了

160
00:11:17,078 --> 00:11:19,012
直接返回就可以了

161
00:11:19,012 --> 00:11:22,026
所以我们需要这么一个term的参数

162
00:11:31,098 --> 00:11:38,074
首先我们定义一个票数的局部变量来进行计票

163
00:11:42,000 --> 00:11:44,008
接着我们就要对

164
00:11:46,084 --> 00:11:48,048
每一个片

165
00:11:55,044 --> 00:11:56,046
构造参数

166
00:11:56,046 --> 00:11:57,064
然后发送RPC

167
00:11:57,064 --> 00:11:59,092
并且处理返回值

168
00:12:02,082 --> 00:12:07,076
由于这我们要访问我们的rap的全局变量

169
00:12:07,076 --> 00:12:09,078
所以我们要加速

170
00:12:19,012 --> 00:12:22,048
如果是自己呢就跳过

171
00:12:23,002 --> 00:12:27,088
但是要给自己的投票制加上

172
00:12:35,008 --> 00:12:37,006
然后如果不是自己

173
00:12:37,006 --> 00:12:42,016
则去构造一下RPP的要票的参数

174
00:12:56,088 --> 00:12:58,072
哦这儿勾long

175
00:12:58,072 --> 00:13:01,000
我们不能在前面加的

176
00:13:03,048 --> 00:13:05,038
我们这儿需要定义一下

177
00:13:05,038 --> 00:13:07,082
我们在这一部分实现

178
00:13:07,082 --> 00:13:11,078
由于所有日志相关的参数都不用管

179
00:13:11,078 --> 00:13:17,067
也就是说我们现在并不需要比较日志谁先谁后

180
00:13:17,067 --> 00:13:21,035
我们可以在下一个part part b的时候

181
00:13:21,035 --> 00:13:22,057
来实现这些逻辑

182
00:13:22,057 --> 00:13:25,019
那本人的逻辑就很简单了

183
00:13:25,019 --> 00:13:30,073
我们只需要一个tom表明自己

184
00:13:30,073 --> 00:13:32,067
candidate term是多少

185
00:13:32,067 --> 00:13:36,056
因为所有比较都是基于term一致展开的

186
00:13:36,056 --> 00:13:37,048
如果term不一致

187
00:13:37,048 --> 00:13:38,004
就要进行

188
00:13:38,004 --> 00:13:39,088
你要么变follower

189
00:13:39,088 --> 00:13:41,092
要么拒绝你的请求

190
00:13:42,033 --> 00:13:44,079
其次呢你要告诉哦

191
00:13:44,079 --> 00:13:46,019
candy的id

192
00:13:46,019 --> 00:13:47,077
我是谁

193
00:13:49,046 --> 00:13:53,038
那一到我们把request word reply写上

194
00:13:53,038 --> 00:13:55,018
首先也是需要一个term

195
00:13:55,018 --> 00:14:02,035
把被要票者的呃term带回来

196
00:14:02,035 --> 00:14:06,049
以就相当于如果自己发现了更高的term

197
00:14:06,049 --> 00:14:10,091
则使用该term来把自己的term带上去

198
00:14:10,091 --> 00:14:12,915
并且变成follow

199
00:14:14,009 --> 00:14:14,085
然后呢

200
00:14:14,085 --> 00:14:23,094
他还得需要一个额是否投给你的物体的grand

201
00:14:32,072 --> 00:14:35,052
这几个参数在论文里都有

202
00:14:35,052 --> 00:14:37,068
大家可以直接抄过来

203
00:14:41,007 --> 00:14:45,016
需要注意的就是首字母都要大写

204
00:14:45,016 --> 00:14:45,009
否则的话

205
00:14:45,009 --> 00:14:47,014
我们的RPC框架

206
00:14:47,014 --> 00:14:50,095
没有办法对它这些参数进行序列化和反序列化

207
00:14:50,095 --> 00:14:56,027
也就无法在RPC的两端之间进行传播

208
00:15:01,058 --> 00:15:03,078
term呢就取我们当前的term

209
00:15:04,098 --> 00:15:09,067
然后candy的id呢就是我们自己的标号

210
00:15:12,086 --> 00:15:15,086
然后就可以去要票了

211
00:15:17,000 --> 00:15:18,006
由于这个是在临界区内

212
00:15:18,006 --> 00:15:20,026
所以我们要异步的进行摇票

213
00:15:20,026 --> 00:15:22,003
而不能同步的发送RPC

214
00:15:22,003 --> 00:15:24,008
否则可能会造成死锁

215
00:15:24,008 --> 00:15:30,092
就是所有需要长时间IO的这种过程

216
00:15:30,092 --> 00:15:32,005
都不能在连接区里面

217
00:15:32,005 --> 00:15:35,024
都要及时把锁释放掉

218
00:15:39,058 --> 00:15:41,088
然后我们再来构造这个函数

219
00:15:41,088 --> 00:15:44,008
我们这个使用一个局部的嵌套函数

220
00:15:44,008 --> 00:15:44,096
是

221
00:15:44,096 --> 00:15:50,034
因为这样我们就可以方便的对这个变量进行嗯

222
00:15:50,034 --> 00:15:53,022
在处理返回值的时候进行加价

223
00:16:01,044 --> 00:16:05,000
这也就是我们的第三个层次

224
00:16:05,000 --> 00:16:10,299
就是最底层的对一个P2发起RPC

225
00:16:10,299 --> 00:16:12,839
并且处理返回值

226
00:16:12,839 --> 00:16:18,022
看人家是否投给自己的票的这么一个逻辑

227
00:16:30,028 --> 00:16:32,036
首先我们要构造一下

228
00:16:32,036 --> 00:16:35,067
构造一个空的返回值结构体

229
00:16:35,067 --> 00:16:38,067
因为我们的RPC需要的是一个指针

230
00:16:38,067 --> 00:16:42,083
所以需要先把这个结构结构导出来

231
00:16:49,068 --> 00:16:52,092
然后我们来发送RPC

232
00:17:02,078 --> 00:17:04,082
这个函数因为是RPC函数

233
00:17:04,082 --> 00:17:06,062
所以你不知道它什么时候返回

234
00:17:06,062 --> 00:17:09,139
所以不能在临界区之内

235
00:17:09,139 --> 00:17:11,179
也就是说不能给他上锁啊

236
00:17:11,179 --> 00:17:12,179
当然也无需上锁

237
00:17:12,179 --> 00:17:15,339
因为他是线程安全的

238
00:17:22,052 --> 00:17:27,056
接下来我们嗯处理我们的response

239
00:17:27,056 --> 00:17:30,004
在这就需要上锁了

240
00:17:31,052 --> 00:17:38,007
因为我们会访问并操作rap的一些全局字段

241
00:17:47,084 --> 00:17:52,052
首先我们判断RPC请求是否成功

242
00:17:53,096 --> 00:17:55,084
如果不成功的话

243
00:17:55,084 --> 00:17:57,002
我们就及时返回

244
00:17:57,002 --> 00:17:59,056
并且打一条日志

245
00:18:20,072 --> 00:18:22,024
并且带出一定的信息

246
00:18:22,024 --> 00:18:25,052
我们到底是问谁要票失败了

247
00:18:31,018 --> 00:18:36,012
接下来嗯第一步就是在我们的所有嗯

248
00:18:36,012 --> 00:18:39,076
无论是收到一个RPC还是RPC请求

249
00:18:39,076 --> 00:18:41,048
还是处理RPC结果的时候

250
00:18:41,048 --> 00:18:44,002
就是收到一个RPC的返回的时候

251
00:18:44,002 --> 00:18:47,082
我们第一步要做的就是要对其

252
00:18:49,056 --> 00:18:50,012
Term

253
00:18:51,036 --> 00:18:53,048
因为只有在同term下

254
00:18:53,048 --> 00:18:55,082
我们之后的状态机才能够推进

255
00:18:55,082 --> 00:19:00,929
否则的话我们的逻辑都会出现问题

256
00:19:03,068 --> 00:19:07,028
如果发现人家的term比我们大的话

257
00:19:08,004 --> 00:19:11,083
我们现在应该是candidate

258
00:19:19,002 --> 00:19:25,001
那其实直接哎就不用做CANDATE

259
00:19:25,001 --> 00:19:28,005
直接变成follower就可以

260
00:19:30,034 --> 00:19:33,058
然后终止要票过程返回

261
00:19:37,038 --> 00:19:39,068
嗯如果他比我们小呢

262
00:19:39,068 --> 00:19:41,057
就不用管

263
00:19:41,085 --> 00:19:43,023
因为他比我们小

264
00:19:43,023 --> 00:19:44,089
他会变成follower

265
00:19:44,089 --> 00:19:47,041
并且投给我们票

266
00:19:49,008 --> 00:19:51,028
接下来第二步就是嗯

267
00:19:52,006 --> 00:19:59,074
看我们的我们自己的term是否发生了变化

268
00:19:59,074 --> 00:20:05,073
也就是嗯我们用一个叫做contest是否lost

269
00:20:06,093 --> 00:20:09,093
因为他也得在临界区里面使用

270
00:20:14,054 --> 00:20:16,094
我们定义一下这个函数

271
00:20:33,002 --> 00:20:38,004
这个函数的意思就是检测我们自身嗯

272
00:20:38,004 --> 00:20:41,008
是否仍为我们发送RPC之前

273
00:20:41,008 --> 00:20:43,031
认为我们自己的角色

274
00:20:43,047 --> 00:20:46,091
以及我们当前是否仍然处于

275
00:20:46,091 --> 00:20:48,081
我们是自自认为的term

276
00:20:48,081 --> 00:20:51,031
因为我们在RPC收到IPC

277
00:20:51,031 --> 00:20:53,092
或者说到RPC返回值的时候

278
00:20:53,092 --> 00:20:55,098
你其实不知道过了多少时间

279
00:20:55,098 --> 00:20:58,036
你也不知道你的上下文是否

280
00:20:58,036 --> 00:21:01,016
因为其他线程的并发操作

281
00:21:01,016 --> 00:21:03,088
已经就是说你已经不是candidate了

282
00:21:03,088 --> 00:21:05,055
你已经不是follower了

283
00:21:05,055 --> 00:21:08,041
或者你已经不在你认为的term上了

284
00:21:08,041 --> 00:21:12,063
那在这时候都要及时终止我们这些回调函数

285
00:21:12,063 --> 00:21:14,097
或者请求返回的处理

286
00:21:14,097 --> 00:21:17,065
否则的话就会让状态机出现问题

287
00:21:17,065 --> 00:21:20,083
因为你在一个不正确的假设上进行

288
00:21:20,083 --> 00:21:24,054
进行了状态机的推进就会产生问题

289
00:21:25,067 --> 00:21:28,047
所以我们要检测水

290
00:21:28,047 --> 00:21:30,095
可检测我们的

291
00:21:32,098 --> 00:21:36,066
这两个东西term和roll

292
00:21:52,018 --> 00:21:54,005
返回一个布尔

293
00:22:05,016 --> 00:22:08,032
在这我们得认为我们还在执行这个过程

294
00:22:08,032 --> 00:22:10,008
我们必须是candidate

295
00:22:10,008 --> 00:22:15,469
并且我们的term是传进来的term

296
00:22:15,989 --> 00:22:19,013
因为这个函数只负责这一个term的选举

297
00:22:19,013 --> 00:22:21,025
如果当前我们term已经发生了变化

298
00:22:21,025 --> 00:22:23,063
那就不是这个函数该管的事情了

299
00:22:23,063 --> 00:22:27,029
我们会有一个新的函数来管这些事情

300
00:22:32,072 --> 00:22:35,082
嗯到这我们就直接返回

301
00:22:35,082 --> 00:22:38,036
然后打一条日志

302
00:23:19,000 --> 00:23:21,079
最后在对齐term

303
00:23:21,079 --> 00:23:23,065
并且上下文没有丢失

304
00:23:23,065 --> 00:23:26,017
也就是说我们仍是那个角色

305
00:23:26,017 --> 00:23:27,061
和在那个term的时候

306
00:23:27,061 --> 00:23:32,399
我们再来检查我们的当前的人家

307
00:23:32,399 --> 00:23:34,599
是否投给了我们票

308
00:23:40,054 --> 00:23:42,034
添点注释

309
00:23:47,003 --> 00:23:49,082
然后我们每测

310
00:23:53,036 --> 00:23:59,096
如果发现WSS大于半数之后

311
00:24:02,056 --> 00:24:04,084
嗯这我们是大于而不是大于等于的

312
00:24:04,084 --> 00:24:06,007
原因在于我们是向下取整

313
00:24:06,007 --> 00:24:09,002
所以是需要大于

314
00:24:11,006 --> 00:24:14,006
我们就会变成leader

315
00:24:14,006 --> 00:24:17,072
然后发起

316
00:24:20,012 --> 00:24:22,086
心跳和日志同步

317
00:24:23,022 --> 00:24:27,032
我们不妨称之为replication ticker

318
00:24:27,032 --> 00:24:32,036
和我们下面这个election ticker相对

319
00:24:33,017 --> 00:24:35,015
他也需要创建一个term进去

320
00:24:35,015 --> 00:24:38,409
也就意味着它只有在这个term的时候才会主

321
00:24:38,409 --> 00:24:40,649
如果之后的一切状态随变了

322
00:24:40,649 --> 00:24:44,609
不在这TM他都要及时终止这个函数

323
00:24:47,006 --> 00:24:48,052
好这儿

324
00:24:48,052 --> 00:24:53,022
其实我们这个发送方的逻辑就完了

325
00:24:53,022 --> 00:24:56,028
但其实我们在构造函数进行

326
00:24:58,062 --> 00:25:05,072
我们在对我们在进来这个选举函数的时候

327
00:25:05,072 --> 00:25:09,006
因为我们也是用了一个go routine

328
00:25:09,006 --> 00:25:13,002
所以最好就所有这种异步的都先检查一下

329
00:25:13,002 --> 00:25:15,409
我们的context是否lost

330
00:25:15,409 --> 00:25:17,369
因为如果已经饿死了的话

331
00:25:17,369 --> 00:25:19,709
其实后面这些就都完全不用管

332
00:25:19,709 --> 00:25:20,829
不用干了

333
00:25:20,829 --> 00:25:23,021
而不用到哦

334
00:25:23,021 --> 00:25:27,003
我们在处理RPC返回的时候才去检测

335
00:25:27,003 --> 00:25:33,549
这样可以提前嗯规避一些事情

336
00:25:37,036 --> 00:25:39,008
就如果我们这个函数一进来就发现

337
00:25:39,008 --> 00:25:42,092
我们已经不是在这个term的candidate了

338
00:25:42,092 --> 00:25:46,016
那直接其实就可以返回就好了

339
00:25:54,036 --> 00:25:57,028
嗯在这我们也加一条日志吧

340
00:26:43,024 --> 00:26:44,092
日志不要过长

341
00:26:44,092 --> 00:26:46,068
但要体现关键信息

342
00:26:46,068 --> 00:26:49,056
但我们怎么知道哪些是关键信息呢

343
00:26:49,056 --> 00:26:52,000
嗯这个完全是基于经验

344
00:26:52,000 --> 00:26:55,189
一开始的话我们可以嗯随便写

345
00:26:55,189 --> 00:26:57,309
等之后我们在调试的时候

346
00:26:57,309 --> 00:27:00,469
我们会发现嗯有一些信息我们想看

347
00:27:00,469 --> 00:27:00,989
但是没有

348
00:27:00,989 --> 00:27:02,109
然后再回来加

349
00:27:02,109 --> 00:27:06,001
所以这呃一开始不知道写哪些关键信息

350
00:27:06,001 --> 00:27:07,001
也没有事情

351
00:27:07,001 --> 00:27:08,062
这都是一个经验的问题

352
00:27:08,062 --> 00:27:11,088
在你调试的过程中就会发现哪些需要写

353
00:27:11,088 --> 00:27:14,068
哪些是冗余的

354
00:27:17,012 --> 00:27:19,008
好那个发送方的逻辑就这样了

355
00:27:19,008 --> 00:27:23,004
然后我们接下来实现这个回调函数

356
00:27:23,004 --> 00:27:25,009
也就是接收方的逻辑

357
00:27:25,009 --> 00:27:28,035
我们在嗯接收方的时候

358
00:27:28,035 --> 00:27:31,071
嗯接触到RPC的第一件事情

359
00:27:31,071 --> 00:27:34,029
也是要

360
00:27:35,025 --> 00:27:35,097
对齐

361
00:27:39,017 --> 00:27:40,073
Term

362
00:27:41,049 --> 00:27:46,037
那当然这些处理额我们都先加一把大锁

363
00:27:47,001 --> 00:27:50,032
加锁的原则就是一开始都先加一把大锁

364
00:27:50,032 --> 00:27:54,006
然后发现有问题再拆分嗯

365
00:27:54,006 --> 00:27:55,068
有性能问题再进行拆分

366
00:27:55,068 --> 00:27:59,012
当然如果有思索也得需要呃注意

367
00:27:59,012 --> 00:28:01,048
但需要额虽然是一把大锁

368
00:28:01,048 --> 00:28:02,024
也要注意

369
00:28:02,024 --> 00:28:05,008
不要把一些长时间的L

370
00:28:05,008 --> 00:28:09,016
比如说RPC的过程给加进去

371
00:28:20,036 --> 00:28:21,004
好在此之前

372
00:28:21,004 --> 00:28:24,088
我们先把返回值构造一下

373
00:28:26,096 --> 00:28:31,003
百分之现在主要有term和是否投给了彩票

374
00:28:31,003 --> 00:28:33,025
Vogranted

375
00:28:33,081 --> 00:28:38,005
后者的话需要根据每一个逻辑来判断

376
00:28:40,001 --> 00:28:42,000
首先我们要对齐term

377
00:28:42,000 --> 00:28:48,007
我们如果发现人家的term比我们小

378
00:28:51,082 --> 00:28:54,028
那集直接拒绝这个请求就行了

379
00:28:54,028 --> 00:28:59,095
因为term在rap的本质是一种嗯EPOC

380
00:28:59,095 --> 00:29:02,099
或者说一种优先级的概念

381
00:29:02,099 --> 00:29:06,006
就所有具有高term的皮尔

382
00:29:06,006 --> 00:29:08,058
可以无视第一term的任何请求

383
00:29:08,058 --> 00:29:10,096
并且告诉他我比你高

384
00:29:10,096 --> 00:29:12,008
你赶紧给我

385
00:29:12,008 --> 00:29:13,086
你赶紧跟上我

386
00:29:14,018 --> 00:29:17,036
那么其他的PR通过IPC知道了之后

387
00:29:17,036 --> 00:29:18,062
就要及时跟上

388
00:29:18,062 --> 00:29:20,048
并且变follower

389
00:29:20,048 --> 00:29:25,034
所以对这种请求我们直接拒绝就好

390
00:29:47,016 --> 00:29:49,006
然后打上一条日志

391
00:30:04,092 --> 00:30:07,004
还是说这个日志的信息

392
00:30:07,008 --> 00:30:09,000
大家可能会好奇

393
00:30:09,000 --> 00:30:09,094
为什么那么打

394
00:30:09,094 --> 00:30:11,064
我也是我也是先打这些

395
00:30:11,064 --> 00:30:12,098
根据我之前的经验等

396
00:30:12,098 --> 00:30:14,064
之后如果出现问题

397
00:30:14,064 --> 00:30:15,072
调试的时候有问题

398
00:30:15,072 --> 00:30:21,003
咱们再回来完善或者去掉一些荣誉的信息

399
00:30:22,039 --> 00:30:26,055
然后如果人家的term比我们大

400
00:30:27,119 --> 00:30:30,004
我们就要变follower

401
00:30:38,036 --> 00:30:40,028
但是变了follower要反了么

402
00:30:40,028 --> 00:30:41,024
不变了

403
00:30:41,024 --> 00:30:44,429
follower你反而还要投票

404
00:30:44,429 --> 00:30:46,169
因为变了follower之后

405
00:30:46,169 --> 00:30:48,009
你的投票肯定就空出来了

406
00:30:48,009 --> 00:30:51,084
也就是说我们在变follower的时候

407
00:30:51,084 --> 00:30:54,004
你如果别人比我们大

408
00:30:54,004 --> 00:30:56,036
我们是会把投票滞空的

409
00:30:56,036 --> 00:31:00,048
这时候你就在本轮次就可以进行投票

410
00:31:00,048 --> 00:31:02,056
所以我们这不能返回

411
00:31:02,056 --> 00:31:04,064
要接着进行以下的逻辑

412
00:31:04,064 --> 00:31:09,949
到这我们就把请求方的term和我们的term呃

413
00:31:09,949 --> 00:31:10,929
进行了对齐

414
00:31:10,929 --> 00:31:12,409
就会比我们小

415
00:31:12,409 --> 00:31:14,209
比我们大的逻辑进行进行处理

416
00:31:14,209 --> 00:31:16,058
那到了这的话嗯

417
00:31:16,058 --> 00:31:20,034
请求方的term和我们的term就一致了

418
00:31:21,014 --> 00:31:24,094
然后我们就需要check the word for

419
00:31:28,000 --> 00:31:31,044
也就是看我们是否在本轮次投过票

420
00:31:39,078 --> 00:31:41,002
如果我们投过

421
00:31:42,007 --> 00:31:43,054
那就拒绝

422
00:31:43,054 --> 00:31:46,038
这次要不要请求

423
00:31:58,006 --> 00:32:00,058
这我们有一个空格的原因是因为我们在这

424
00:32:00,058 --> 00:32:06,001
其实我们在log里隐含的加了一个空格

425
00:32:06,001 --> 00:32:10,041
所以我们在后面为了让箭头两侧是对称的

426
00:32:10,041 --> 00:32:12,057
所以这也加一个空格

427
00:32:27,001 --> 00:32:29,000
你拒绝了CANDATE的投票

428
00:32:29,000 --> 00:32:32,096
因为我们已经投给了某个人

429
00:32:34,012 --> 00:32:35,084
能返回

430
00:32:38,082 --> 00:32:42,002
接下来其实如果我们在正常的rap的逻辑里

431
00:32:42,002 --> 00:32:47,072
还要比较我们的日志是否哦比你的心

432
00:32:47,072 --> 00:32:48,078
如果我们比你的心

433
00:32:48,078 --> 00:32:49,074
我们就不投给你

434
00:32:49,074 --> 00:32:50,066
如果你的更新

435
00:32:50,066 --> 00:32:51,008
我们就投给你

436
00:32:51,008 --> 00:32:53,066
但是因为由于怕太黑

437
00:32:53,066 --> 00:32:57,006
我们不涉及日志这一块的逻辑

438
00:32:57,006 --> 00:33:01,033
所以我们就直接可以把票投给你了

439
00:33:01,093 --> 00:33:04,033
首先通过reply告诉我

440
00:33:04,033 --> 00:33:06,069
我可以给你票

441
00:33:08,052 --> 00:33:12,004
哦当然这儿我们在返回的时候

442
00:33:16,032 --> 00:33:18,098
忘了说它是false

443
00:33:18,098 --> 00:33:21,003
但是我们可以在外外面给它

444
00:33:21,003 --> 00:33:24,082
默认的给它复制成false

445
00:33:24,082 --> 00:33:27,086
就表示我们默认是不给你票的

446
00:33:27,086 --> 00:33:29,062
只有到了层层过滤

447
00:33:29,062 --> 00:33:33,045
最后之后我们发现所有条件都满足了

448
00:33:33,045 --> 00:33:35,069
我们才会给你标

449
00:33:39,064 --> 00:33:42,078
然后第一句是告诉你

450
00:33:42,078 --> 00:33:43,048
我给你票

451
00:33:43,048 --> 00:33:46,026
第二句是我自己要记下的

452
00:33:46,026 --> 00:33:48,066
我已经给了这个人票

453
00:33:49,007 --> 00:33:51,087
并且如果我在给出票去之后

454
00:33:51,087 --> 00:33:54,051
就相当于我认可了你这个candidate

455
00:33:54,051 --> 00:33:57,052
你可以有变成leader的潜质

456
00:33:57,088 --> 00:33:59,052
那也就类似于

457
00:33:59,052 --> 00:34:03,018
其实我收到了准leader或者leader的这种请求

458
00:34:03,018 --> 00:34:06,409
我就可以重置我自己的选举失重

459
00:34:06,409 --> 00:34:08,609
来给你提供一个保证

460
00:34:08,609 --> 00:34:11,529
我暂时不会发起新的选举

461
00:34:12,074 --> 00:34:14,009
然后打一条日志

462
00:34:39,001 --> 00:34:42,005
嗯这个大消息我也搞得不太一致

463
00:34:42,005 --> 00:34:46,008
大家可以自己搞一下

464
00:34:46,008 --> 00:34:47,096
比如所有逗号之后都可以大一些

465
00:34:47,096 --> 00:34:50,052
但也可以指首字母大写

466
00:34:50,052 --> 00:34:51,054
这个都无关紧要

467
00:34:51,054 --> 00:34:55,004
但是已知的话会好看一些

468
00:35:04,001 --> 00:35:08,002
到这儿我们就实现了part a中

469
00:35:08,002 --> 00:35:10,024
所有关于选举的逻辑

470
00:35:10,024 --> 00:35:11,054
之后

471
00:35:11,054 --> 00:35:13,007
下一个视频我们会讲

472
00:35:13,007 --> 00:35:16,086
实现那个不带日志的心跳逻辑

